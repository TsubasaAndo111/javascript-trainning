# 以下の各関数を実行すると何が出力されるか予想し実際に確認しなさい。またその理由を 2、3 行のテキスト、図のいずれかまたは両方で説明しなさい

- i1  
   [予想]  
   1秒後に42が出力され、その２秒後に100が出力される。

  [結果]

  ```
  42
  100
  ```

  [理由]
  Promise.any()は最初に成功するPromiseの値を返すため、wait1().thenの値である42がvの値となる。  
  そのため、プログラムを実行した１秒後に最初のlog(v)が実行され、42が出力される。  
  wait2()で待っている間に、Promise.any内のwait2.then.thenも非同期で動いており、v=100でvの値が変更される。  
  そのため、２度目のlog(v)で100が出力される。

- i2
  [予想]  
   1秒後にCが出力され、２秒後にBが出力され、３秒後にAが出力される。  
   最後に、配列[C, B, A]が出力される。  
   [結果]

  ```
  C
  B
  A
  [ 'A', 'B', 'C' ]
  ```

  [理由]  
  Promise.allは全部完了するまで待ち、それぞれの出力が配列となる。  
  そのため、wait3.then,wait2.then,wait1.thenをそれぞれ待つ。  
  したがって、1秒後にC、２秒後にB、3秒後にAが出力される。  
  また、それぞれのreturnが配列として返されるため、 [ 'A', 'B', 'C' ]が出力される。  
  配列の順番はPromise.allに渡した引数の順番となる。

- i3  
   [予想]  
   　　1秒後にYと42が出力され、３秒後に0が出力される
  [結果]

  ```
  Y
  42
  B
  0
  ```

  [理由]
  Promise.allは１つでも失敗したらrejectとなる。  
  そのため、wait1終了時にerrY()が発生し、catchされ、Yが出力される。  
  この時点で１秒しか経過していないため、vは初期値であり、42が出力される。  
  そして、await3の間に、wait2.thenが完了し、Bが出力される。
  最後に、await3()の間にwait3.then内のv=0も実行されるため、0が出力される。

- i4  
   [予想]
  　10
  [結果]

  ```
  5
  ```

  [理由]  
  p2の方がp1よりも１秒早くスタートする。  
  p1はp2更新前のvでnextを算出しており、結局p1のループの結果しか反映されていない。
  そのため、v=5となる。
